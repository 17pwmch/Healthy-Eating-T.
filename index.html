<!doctype html>
<html lang="th" class="h-full">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Healthy Eating Challenge AR</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    
    @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap');
    
    * {
      font-family: 'Fredoka', 'Comic Sans MS', cursive, sans-serif;
    }
    
    .game-container {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      position: relative;
      overflow: hidden;
    }

    #videoBackground {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
      z-index: 1;
    }

    .game-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
      pointer-events: none;
    }
    
    .food-item {
      transition: transform 0.1s ease;
      pointer-events: none;
    }
    
    @keyframes fall {
      from {
        transform: translateY(-100px);
      }
      to {
        transform: translateY(calc(100vh + 100px));
      }
    }
    
    .falling {
      animation: fall linear forwards;
    }
    
    @keyframes pulse {
      0%, 100% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.05);
      }
    }
    
    .pulse {
      animation: pulse 1s ease-in-out infinite;
    }
    
    .mouth-indicator {
      position: absolute;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      border: 5px solid #10b981;
      transition: all 0.1s ease;
      pointer-events: none;
      z-index: 30;
      background: rgba(16, 185, 129, 0.1);
    }
    
    .mouth-open-indicator {
      border-color: #10b981;
      border-width: 6px;
      box-shadow: 0 0 40px rgba(16, 185, 129, 0.8);
      background: rgba(16, 185, 129, 0.2);
      animation: pulse 0.5s ease-in-out infinite;
    }

    .mouth-closed-indicator {
      border-color: #6b7280;
      border-width: 3px;
      background: rgba(107, 114, 128, 0.1);
    }

    .debug-info {
      font-size: 13px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      line-height: 1.6;
      pointer-events: auto;
    }

    @keyframes catch-effect {
      0% {
        transform: scale(1) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: scale(0) rotate(360deg);
        opacity: 0;
      }
    }

    .catch-effect {
      animation: catch-effect 0.3s ease-out;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-10px); }
      75% { transform: translateX(10px); }
    }

    .ui-element {
      pointer-events: auto;
    }
  </style>
 </head>
 <body class="h-full">
  <div id="app" class="w-full h-full"></div>
  <script>
    const defaultConfig = {
      game_title: "üçé AR Healthy Eating Challenge ü•ó",
      instruction_text: "Use your REAL mouth to catch falling food!",
      background_color: "#667eea",
      surface_color: "#ffffff",
      text_color: "#1f2937",
      primary_action_color: "#10b981",
      secondary_action_color: "#8b5cf6"
    };

    let config = { ...defaultConfig };
    let detector = null;
    let videoStream = null;
    let gameState = {
      screen: 'menu',
      level: 1,
      score: 0,
      healthyCount: 0,
      junkCount: 0,
      lives: 3,
      mouthOpen: false,
      gameActive: false,
      playerName: '',
      fallingItems: [],
      mouthDistance: 0,
      faceDetected: false,
      mouthX: 50,
      mouthY: 50,
      videoWidth: 640,
      videoHeight: 480
    };

    const levels = [
      { name: "Breakfast Challenge", duration: 30, speed: 4 },
      { name: "Lunch Rush", duration: 40, speed: 3.5 },
      { name: "Dinner Dash", duration: 50, speed: 3 },
      { name: "Midnight Snack", duration: 60, speed: 2.5 },
      { name: "Ultimate Food Master", duration: 90, speed: 2 }
    ];

    const healthyFoods = ['üçé', 'ü•ó', 'ü•¶', 'ü•ï', 'üçä', 'üçá', 'ü•ë', 'üçì'];
    const junkFoods = ['üçî', 'üçï', 'üçü', 'üç©', 'üç∞', 'üå≠', 'üçø', 'üç´'];
    const bombs = ['üí£'];

    async function setupCamera() {
      try {
        showToast('‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á... / Opening camera...', 'info');
        
        videoStream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: 'user',
            width: { ideal: 1280 },
            height: { ideal: 720 }
          } 
        });
        
        const video = document.getElementById('videoBackground');
        if (video) {
          video.srcObject = videoStream;
          await video.play();
          
          gameState.videoWidth = video.videoWidth || 640;
          gameState.videoHeight = video.videoHeight || 480;
          
          showToast('‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î Face Detection... / Loading face detection...', 'info');
          
          const model = faceLandmarksDetection.SupportedModels.MediaPipeFaceMesh;
          const detectorConfig = {
            runtime: 'tfjs',
            refineLandmarks: true,
            maxFaces: 1
          };
          
          detector = await faceLandmarksDetection.createDetector(model, detectorConfig);
          
          showToast('‚úÖ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°! ‡∏≠‡πâ‡∏≤‡∏õ‡∏≤‡∏Å‡∏£‡∏±‡∏ö‡∏ú‡∏•‡πÑ‡∏°‡πâ! / Start! Open mouth!', 'success');
          detectMouth();
        }
      } catch (error) {
        console.error('Camera error:', error);
        showToast('‚ùå ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏Å‡∏•‡πâ‡∏≠‡∏á / Please allow camera access', 'error');
      }
    }

    async function detectMouth() {
      if (!gameState.gameActive || !detector) return;

      const video = document.getElementById('videoBackground');
      if (!video || video.readyState < 2) {
        requestAnimationFrame(detectMouth);
        return;
      }

      try {
        const faces = await detector.estimateFaces(video);
        
        if (faces.length > 0) {
          gameState.faceDetected = true;
          const keypoints = faces[0].keypoints;
          
          const upperLip = keypoints[13];
          const lowerLip = keypoints[14];
          
          if (upperLip && lowerLip) {
            // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏õ‡∏≤‡∏Å‡πÉ‡∏ô‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠
            const mouthCenterX = (upperLip.x + lowerLip.x) / 2;
            const mouthCenterY = (upperLip.y + lowerLip.y) / 2;
            
            // ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ö‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠ (‡∏Å‡∏•‡∏±‡∏ö‡∏ã‡πâ‡∏≤‡∏¢-‡∏Ç‡∏ß‡∏≤‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠ mirror)
            const videoElement = document.getElementById('videoBackground');
            const videoRect = videoElement.getBoundingClientRect();
            
            // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì scale ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏Å‡∏±‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠
            const scaleX = videoRect.width / gameState.videoWidth;
            const scaleY = videoRect.height / gameState.videoHeight;
            
            // ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏à‡∏£‡∏¥‡∏á‡∏ö‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠ (flip X ‡πÄ‡∏û‡∏£‡∏≤‡∏∞ mirror)
            const screenX = videoRect.width - (mouthCenterX * scaleX);
            const screenY = mouthCenterY * scaleY;
            
            gameState.mouthX = screenX;
            gameState.mouthY = screenY;
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏õ‡∏≤‡∏Å‡πÄ‡∏õ‡∏¥‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            const mouthOpenDistance = Math.abs(lowerLip.y - upperLip.y);
            gameState.mouthDistance = Math.round(mouthOpenDistance);
            gameState.mouthOpen = mouthOpenDistance > 10;
            
            // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ï‡∏±‡∏ß‡∏ö‡πà‡∏á‡∏ä‡∏µ‡πâ‡∏õ‡∏≤‡∏Å
            updateMouthIndicator();
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏≠‡∏≤‡∏´‡∏≤‡∏£
            checkFoodCatchContinuous();
            
            updateDebugInfo();
          }
        } else {
          gameState.faceDetected = false;
          updateDebugInfo();
        }
      } catch (error) {
        console.error('Face detection error:', error);
      }

      if (gameState.gameActive) {
        requestAnimationFrame(detectMouth);
      }
    }

    function updateMouthIndicator() {
      const indicator = document.getElementById('mouthIndicator');
      if (!indicator) return;
      
      // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
      indicator.style.left = `${gameState.mouthX}px`;
      indicator.style.top = `${gameState.mouthY}px`;
      indicator.style.transform = 'translate(-50%, -50%)';
      
      // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡πÑ‡∏ï‡∏•‡πå‡∏ï‡∏≤‡∏°‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞
      if (gameState.mouthOpen) {
        indicator.classList.remove('mouth-closed-indicator');
        indicator.classList.add('mouth-open-indicator');
      } else {
        indicator.classList.remove('mouth-open-indicator');
        indicator.classList.add('mouth-closed-indicator');
      }
    }

    function updateDebugInfo() {
      const debugEl = document.getElementById('debugInfo');
      if (debugEl) {
        debugEl.innerHTML = `
          Face: ${gameState.faceDetected ? '‚úÖ' : '‚ùå'} | 
          Mouth: ${gameState.mouthDistance}px ${gameState.mouthOpen ? 'üòÆ OPEN' : 'üòê'}<br>
          Position: X=${Math.round(gameState.mouthX)} Y=${Math.round(gameState.mouthY)} | 
          Items: ${gameState.fallingItems.filter(i => !i.caught).length}
        `;
      }
    }

    function checkFoodCatchContinuous() {
      if (!gameState.mouthOpen || !gameState.faceDetected) return;

      gameState.fallingItems.forEach((item) => {
        if (item.caught) return;

        const element = document.getElementById(`food-${item.id}`);
        if (!element) return;

        const rect = element.getBoundingClientRect();
        const itemCenterX = rect.left + rect.width / 2;
        const itemCenterY = rect.top + rect.height / 2;

        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏õ‡∏≤‡∏Å‡∏Å‡∏±‡∏ö‡∏≠‡∏≤‡∏´‡∏≤‡∏£
        const distance = Math.sqrt(
          Math.pow(itemCenterX - gameState.mouthX, 2) + 
          Math.pow(itemCenterY - gameState.mouthY, 2)
        );

        // ‡∏ñ‡πâ‡∏≤‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏û‡∏≠ (‡∏£‡∏±‡∏®‡∏°‡∏µ‡∏à‡∏±‡∏ö 90px)
        if (distance < 90) {
          catchFood(item, element);
        }
      });
    }

    function catchFood(item, element) {
      item.caught = true;
      
      element.classList.add('catch-effect');
      
      setTimeout(() => {
        if (element.parentNode) {
          element.style.display = 'none';
        }
      }, 100);

      if (item.type === 'bomb') {
        gameState.lives--;
        showToast('üí• ‡πÇ‡∏î‡∏ô‡∏£‡∏∞‡πÄ‡∏ö‡∏¥‡∏î! -1 ‚ù§Ô∏è', 'error');
        playSound('bomb');
        
        const gameArea = document.body;
        gameArea.style.animation = 'shake 0.3s';
        setTimeout(() => {
          gameArea.style.animation = '';
        }, 300);
        
        if (gameState.lives <= 0) {
          endGame();
        }
      } else if (item.type === 'healthy') {
        gameState.score += 10;
        gameState.healthyCount++;
        showToast('‚ú® ‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏î‡∏µ! +10 üçé', 'success');
        playSound('success');
      } else {
        gameState.score += 5;
        gameState.junkCount++;
        showToast('üçî ‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏Ç‡∏¢‡∏∞ +5', 'warning');
        playSound('junk');
      }

      updateGameUI();
    }

    function playSound(type) {
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        if (type === 'success') {
          oscillator.frequency.value = 800;
          gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
        } else if (type === 'bomb') {
          oscillator.frequency.value = 100;
          gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
        } else {
          oscillator.frequency.value = 400;
          gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
        }
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.3);
      } catch (e) {
        console.log('Sound not supported');
      }
    }

    function startGame(level) {
      gameState.level = level;
      gameState.score = 0;
      gameState.healthyCount = 0;
      gameState.junkCount = 0;
      gameState.lives = 3;
      gameState.gameActive = true;
      gameState.fallingItems = [];
      gameState.screen = 'game';
      
      render();
      setupCamera();
      spawnFoodItems();
      startGameTimer();
    }

    function spawnFoodItems() {
      if (!gameState.gameActive) return;

      const levelData = levels[gameState.level - 1];
      
      const rand = Math.random();
      let randomFood;
      
      if (rand < 0.5) {
        randomFood = healthyFoods[Math.floor(Math.random() * healthyFoods.length)];
      } else if (rand < 0.85) {
        randomFood = junkFoods[Math.floor(Math.random() * junkFoods.length)];
      } else {
        randomFood = bombs[0];
      }
      
      let type = 'healthy';
      if (junkFoods.includes(randomFood)) type = 'junk';
      if (bombs.includes(randomFood)) type = 'bomb';

      const item = {
        id: Date.now() + Math.random(),
        emoji: randomFood,
        type: type,
        x: Math.random() * 80 + 10,
        caught: false
      };

      gameState.fallingItems.push(item);

      const gameArea = document.getElementById('gameOverlay');
      if (gameArea) {
        const foodEl = document.createElement('div');
        foodEl.id = `food-${item.id}`;
        foodEl.className = 'falling food-item';
        foodEl.style.cssText = `
          position: absolute;
          left: ${item.x}%;
          top: -100px;
          font-size: 64px;
          z-index: 20;
          animation-duration: ${levelData.speed}s;
          filter: drop-shadow(3px 3px 6px rgba(0,0,0,0.7));
        `;
        foodEl.textContent = item.emoji;
        gameArea.appendChild(foodEl);

        setTimeout(() => {
          if (foodEl.parentNode) {
            foodEl.remove();
          }
          const index = gameState.fallingItems.indexOf(item);
          if (index > -1) {
            gameState.fallingItems.splice(index, 1);
          }
        }, levelData.speed * 1000);
      }

      setTimeout(() => spawnFoodItems(), 1200 / Math.sqrt(levelData.speed));
    }

    function startGameTimer() {
      const levelData = levels[gameState.level - 1];
      let timeLeft = levelData.duration;

      const timer = setInterval(() => {
        if (!gameState.gameActive) {
          clearInterval(timer);
          return;
        }

        timeLeft--;
        const timerEl = document.getElementById('timer');
        if (timerEl) {
          timerEl.textContent = `‚è±Ô∏è ${timeLeft}s`;
        }

        if (timeLeft <= 0) {
          clearInterval(timer);
          endGame();
        }
      }, 1000);
    }

    function endGame() {
      gameState.gameActive = false;
      
      if (videoStream) {
        videoStream.getTracks().forEach(track => track.stop());
      }

      gameState.screen = 'result';
      render();
    }

    function updateGameUI() {
      const scoreEl = document.getElementById('score');
      const livesEl = document.getElementById('lives');
      
      if (scoreEl) scoreEl.textContent = `üèÜ ${gameState.score}`;
      if (livesEl) livesEl.textContent = `‚ù§Ô∏è ${gameState.lives}`;
    }

    function showToast(message, type = 'info') {
      const toast = document.createElement('div');
      toast.className = 'fixed top-24 left-1/2 transform -translate-x-1/2 px-6 py-3 rounded-lg shadow-lg font-bold';
      toast.style.cssText = `
        background: ${type === 'error' ? '#ef4444' : type === 'success' ? '#10b981' : '#f59e0b'};
        color: white;
        z-index: 100;
      `;
      toast.textContent = message;
      document.body.appendChild(toast);

      setTimeout(() => toast.remove(), 1500);
    }

    function getCharacterEmoji() {
      const ratio = gameState.healthyCount / (gameState.healthyCount + gameState.junkCount || 1);
      if (ratio > 0.7) return 'üí™üòä';
      if (ratio > 0.4) return 'üòê';
      return 'üò∞üçî';
    }

    function getResultMessage() {
      const ratio = gameState.healthyCount / (gameState.healthyCount + gameState.junkCount || 1);
      if (ratio > 0.7) return '‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û‡∏î‡∏µ‡∏°‡∏≤‡∏Å! / Excellent Health!';
      if (ratio > 0.4) return '‡∏û‡∏≠‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ / Fair Health';
      return '‡∏Ñ‡∏ß‡∏£‡∏î‡∏π‡πÅ‡∏•‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô / Need Better Choices!';
    }

    function render() {
      const app = document.getElementById('app');
      const bgColor = config.background_color;
      const surfaceColor = config.surface_color;
      const textColor = config.text_color;
      const primaryColor = config.primary_action_color;
      const secondaryColor = config.secondary_action_color;

      if (gameState.screen === 'menu') {
        app.innerHTML = `
          <div class="game-container w-full h-full flex items-center justify-center p-8" style="background: ${bgColor};">
            <div class="text-center max-w-2xl" style="background: ${surfaceColor}; border-radius: 24px; padding: 48px; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
              <h1 class="text-6xl font-bold mb-6 pulse" style="color: ${textColor};">${config.game_title}</h1>
              <p class="text-xl mb-8" style="color: ${textColor};">${config.instruction_text}</p>
              
              <div class="mb-6 p-6 rounded-xl" style="background: ${primaryColor}20; border: 2px solid ${primaryColor};">
                <p class="text-2xl font-bold mb-3" style="color: ${textColor};">üí° ‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏•‡πà‡∏ô / How to Play:</p>
                <p class="text-lg mb-2" style="color: ${textColor};">üìπ ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á</p>
                <p class="text-lg mb-2" style="color: ${textColor};">üëÑ ‡πÉ‡∏ä‡πâ‡∏õ‡∏≤‡∏Å‡∏à‡∏£‡∏¥‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏à‡∏±‡∏ö‡∏≠‡∏≤‡∏´‡∏≤‡∏£</p>
                <p class="text-lg mb-2" style="color: ${textColor};">üòÆ ‡∏≠‡πâ‡∏≤‡∏õ‡∏≤‡∏Å‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏°‡∏≤‡∏ñ‡∏∂‡∏á‡∏õ‡∏≤‡∏Å</p>
                <p class="text-lg" style="color: ${textColor};">üéØ ‡∏ß‡∏á‡∏Å‡∏•‡∏°‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß = ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏à‡∏±‡∏ö!</p>
              </div>
              
              <input 
                type="text" 
                id="playerNameInput" 
                placeholder="‡∏ä‡∏∑‡πà‡∏≠‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì / Your Name" 
                class="w-full px-6 py-4 text-xl rounded-xl mb-6 border-4 outline-none"
                style="border-color: ${primaryColor}; color: ${textColor};"
              />
              
              <div class="space-y-4">
                ${levels.map((level, index) => `
                  <button 
                    onclick="gameState.playerName = document.getElementById('playerNameInput').value || 'Player'; startGame(${index + 1})"
                    class="w-full px-8 py-4 text-xl font-bold rounded-xl transition-all hover:scale-105"
                    style="background: ${index === 0 ? primaryColor : secondaryColor}; color: white;"
                  >
                    Level ${index + 1}: ${level.name} (${level.duration}s)
                  </button>
                `).join('')}
              </div>
            </div>
          </div>
        `;
      } else if (gameState.screen === 'game') {
        app.innerHTML = `
          <div class="game-container w-full h-full relative">
            <!-- ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏•‡πâ‡∏≠‡∏á -->
            <video id="videoBackground" autoplay muted playsinline></video>
            
            <!-- Overlay ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÅ‡∏•‡∏∞ UI -->
            <div id="gameOverlay" class="game-overlay">
              <!-- UI Elements -->
              <div class="absolute top-4 left-4 right-4 flex justify-between items-center z-50">
                <div class="flex gap-4 flex-wrap">
                  <div class="px-6 py-3 rounded-xl font-bold text-2xl ui-element" style="background: rgba(255,255,255,0.9); color: ${textColor}; box-shadow: 0 4px 12px rgba(0,0,0,0.3);" id="score">üèÜ 0</div>
                  <div class="px-6 py-3 rounded-xl font-bold text-2xl ui-element" style="background: rgba(255,255,255,0.9); color: ${textColor}; box-shadow: 0 4px 12px rgba(0,0,0,0.3);" id="lives">‚ù§Ô∏è 3</div>
                  <div class="px-6 py-3 rounded-xl font-bold text-2xl ui-element" style="background: rgba(255,255,255,0.9); color: ${textColor}; box-shadow: 0 4px 12px rgba(0,0,0,0.3);" id="timer">‚è±Ô∏è ${levels[gameState.level - 1].duration}s</div>
                </div>
              </div>

              <!-- Debug Info -->
              <div class="absolute top-24 left-4 z-50 debug-info" id="debugInfo">
                Loading...
              </div>

              <!-- ‡∏ï‡∏±‡∏ß‡∏ö‡πà‡∏á‡∏ä‡∏µ‡πâ‡∏õ‡∏≤‡∏Å (‡∏ß‡∏á‡∏Å‡∏•‡∏°‡∏ó‡∏µ‡πà‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏õ‡∏≤‡∏Å) -->
              <div id="mouthIndicator" class="mouth-indicator mouth-closed-indicator"></div>

              <!-- ‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥ -->
              <div class="absolute bottom-4 left-1/2 transform -translate-x-1/2 z-50 px-6 py-3 rounded-xl text-white font-bold text-xl text-center" style="background: rgba(0,0,0,0.8);">
                üòÆ ‡∏≠‡πâ‡∏≤‡∏õ‡∏≤‡∏Å‡∏£‡∏±‡∏ö‡∏ú‡∏•‡πÑ‡∏°‡πâ! / Open mouth to catch!
              </div>
            </div>
          </div>
        `;
      } else if (gameState.screen === 'result') {
        app.innerHTML = `
          <div class="game-container w-full h-full flex items-center justify-center p-8" style="background: ${bgColor};">
            <div class="text-center max-w-2xl" style="background: ${surfaceColor}; border-radius: 24px; padding: 48px; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
              <div class="text-9xl mb-6 pulse">${getCharacterEmoji()}</div>
              <h2 class="text-5xl font-bold mb-4" style="color: ${textColor};">‡πÄ‡∏Å‡∏°‡∏à‡∏ö‡πÅ‡∏•‡πâ‡∏ß! / Game Over!</h2>
              <h3 class="text-3xl font-bold mb-8" style="color: ${primaryColor};">${getResultMessage()}</h3>
              
              <div class="grid grid-cols-2 gap-6 mb-8">
                <div class="p-6 rounded-xl" style="background: ${bgColor}20;">
                  <div class="text-5xl mb-2">üèÜ</div>
                  <div class="text-3xl font-bold" style="color: ${textColor};">${gameState.score}</div>
                  <div style="color: ${textColor};">‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô / Score</div>
                </div>
                <div class="p-6 rounded-xl" style="background: ${bgColor}20;">
                  <div class="text-5xl mb-2">üçé</div>
                  <div class="text-3xl font-bold" style="color: ${primaryColor};">${gameState.healthyCount}</div>
                  <div style="color: ${textColor};">‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏î‡∏µ / Healthy</div>
                </div>
                <div class="p-6 rounded-xl" style="background: ${bgColor}20;">
                  <div class="text-5xl mb-2">üçî</div>
                  <div class="text-3xl font-bold" style="color: ${secondaryColor};">${gameState.junkCount}</div>
                  <div style="color: ${textColor};">‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏Ç‡∏¢‡∏∞ / Junk</div>
                </div>
                <div class="p-6 rounded-xl" style="background: ${bgColor}20;">
                  <div class="text-5xl mb-2">üìä</div>
                  <div class="text-3xl font-bold" style="color: ${textColor};">${Math.round(gameState.healthyCount / (gameState.healthyCount + gameState.junkCount || 1) * 100)}%</div>
                  <div style="color: ${textColor};">‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û‡∏î
